<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>blogs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="innodb具有高并发, 事物 ,数据安全等特性1.二叉树 平衡树 多叉树 首先我们先了解一下树的概念:    二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。这样如果你要查 ID_card_n2 的话，按照图中的搜索顺序就是按照 UserA -&amp;gt; UserC -&amp;gt; UserF -&amp;gt; User2 这个路 径得到。这个时间复杂度是 O(log(N))。 普通的二">
<meta name="keywords" content="php,java,javascript,node,go,lua,nginx,sphinx,elasticesarch,算法">
<meta property="og:type" content="article">
<meta property="og:title" content="blogs">
<meta property="og:url" content="https://wulimax.github.io/2019/09/16/docs/mysql/mysql_innodb/index.html">
<meta property="og:site_name" content="blogs">
<meta property="og:description" content="innodb具有高并发, 事物 ,数据安全等特性1.二叉树 平衡树 多叉树 首先我们先了解一下树的概念:    二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。这样如果你要查 ID_card_n2 的话，按照图中的搜索顺序就是按照 UserA -&amp;gt; UserC -&amp;gt; UserF -&amp;gt; User2 这个路 径得到。这个时间复杂度是 O(log(N))。 普通的二">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://github.com/wulimax/blogs/blob/master/docs/mysql/image/tree.png">
<meta property="og:image" content="https://github.com/wulimax/blogs/blob/master/docs/mysql/image/tree_1.png">
<meta property="og:image" content="https://github.com/wulimax/blogs/blob/master/docs/mysql/image/redulog.png">
<meta property="og:updated_time" content="2019-06-05T10:37:01.112Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="blogs">
<meta name="twitter:description" content="innodb具有高并发, 事物 ,数据安全等特性1.二叉树 平衡树 多叉树 首先我们先了解一下树的概念:    二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。这样如果你要查 ID_card_n2 的话，按照图中的搜索顺序就是按照 UserA -&amp;gt; UserC -&amp;gt; UserF -&amp;gt; User2 这个路 径得到。这个时间复杂度是 O(log(N))。 普通的二">
<meta name="twitter:image" content="https://github.com/wulimax/blogs/blob/master/docs/mysql/image/tree.png">
  
    <link rel="alternate" href="/atom.xml" title="blogs" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">blogs</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://wulimax.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-docs/mysql/mysql_innodb" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/16/docs/mysql/mysql_innodb/" class="article-date">
  <time datetime="2019-09-16T07:05:47.931Z" itemprop="datePublished">2019-09-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="innodb具有高并发-事物-数据安全等特性"><a href="#innodb具有高并发-事物-数据安全等特性" class="headerlink" title="innodb具有高并发, 事物 ,数据安全等特性"></a>innodb具有高并发, 事物 ,数据安全等特性</h2><p>1.二叉树 平衡树 多叉树</p>
<p>首先我们先了解一下树的概念: </p>
<img src="https://github.com/wulimax/blogs/blob/master/docs/mysql/image/tree.png" height="330" width="495">

<p>二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。这样如果你要查 ID_card_n2 的话，按照图中的搜索顺序就是按照 UserA -&gt; UserC -&gt; UserF -&gt; User2 这个路 径得到。这个时间复杂度是 O(log(N))。</p>
<p><strong>普通的二叉树适用场景查询比较多的情况,但是对于一个经常需要增删改的场景就显得有点鸡肋了</strong> </p>
<p>这时候你就需要保持这棵树是平衡二叉树。为了做这个保 证，更新的时间复杂度也是 O(log(N))。<br>树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右 递增。二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因 是，索引不止存在内存中，还要写到磁盘上。</p>
<p>想象一下一棵 100 万节点的平衡二叉树，树高 20。一次查询可能需要访问 20 个数据 块。在机械硬盘时代，从磁盘随机读一个数据块需要 10 ms 左右的寻址时间。也就是说，对于 一个 100 万行的表，如果使用二叉树来存储，单独访问一个行可能需要 20 个 10 ms 的时间， 这个查询可真够慢的。<br>为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该 使用二叉树，而是要使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块的大小。<br>以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以 存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，一个 10 亿行 的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很 大概率在内存中，那么访问磁盘的平均次数就更少</p>
<p>2.索引</p>
<p>​     主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引, </p>
<p>​      为什么要进行逻辑删除而不要物理删除: a.公司业务需要  b.对表主键进行删除 修改操作会触发页的分裂合并 不建议用</p>
<p>​      为什么要尽量用主键索引: 数据存在于主键索引上 使用普通索引会触发回表 ,可以使用覆盖索引优化</p>
<p>​      force index 可以矫正优化器的选择</p>
<img src="https://github.com/wulimax/blogs/blob/master/docs/mysql/image/tree_1.png" height="330" width="495">

<p>​    可以看出在b+树中,叶子节点会指向他相邻的叶子节点,这样可以有效减少遍历次数</p>
<p>3.锁</p>
<p>​      全局锁: 一般用于数据库备份; 表锁 行锁</p>
<p>   <strong>两阶段锁协议</strong>，整个事务分为两个阶段，前一个阶段为加锁，后一个阶段为解锁。在加锁阶段，事务只能加锁，也可以操作数据，但不能解锁，直到事务释放第一个锁，就进入解锁阶段，此过程中事务只能解锁，也可以操作数据，不能再加锁。两阶段锁协议使得事务具有较高的并发度，因为解锁不必发生在事务结尾。它的不足是没有解决死锁的问题，因为它在加锁阶段没有顺序要求。如两个事务分别申请了A, B锁，接着又申请对方的锁，此时进入死锁状态</p>
<p> <strong>时间戳排序协议</strong>，每个事务都有一个唯一的时间戳，也就是其进入系统的时间。时间戳有大小之分，如果事务Ti比Tj先进入系统，则TS(Ti)&lt;TS(Tj)。对于每个数据项Q，有两个时间戳与其绑定：一个是W-TS(Q)，表示最近一次写数据项Q的事务的时间戳；一个是R-TS(Q)，表示最近一次读数据项Q的事务的时间戳。Thomas协议是对时间戳排序协议的改进，具体内容如下：</p>
<p>若事务Ti发起一个write(Q)，则</p>
<p>如果TS(Ti)&lt;R-TS(Q)，则表明Ti准备写的值还没来得及写入，Q就提前被读取了，所以Ti的write(Q)操作被拒绝，并且事务Ti被回滚。</p>
<p>如果TS(Ti)&lt;W-TS(Q)，表明Ti写的值已过期，比它更新的值已经写到Q上，所以Ti的write(Q)操作被拒绝。</p>
<p>剩下的情况，write(Q)操作被允许</p>
<p><strong>树形协议</strong>，假设数据项的集合满足一个偏序关系，访问数据项必须按此偏序关系的先后进行。如di-&gt;dj，则要想访问dj，必须先访问di。这种偏序关系导出一个有向无环图(DAG)，因此称为树形协议。树形协议的规则有：</p>
<p>树形协议只有独占锁；</p>
<p>事务T第一次加锁可以对任何数据项进行； </p>
<p>此后，事务T对数据项Q的加锁前提是持有Q的父亲数据项的锁； </p>
<p>对数据项的解锁可以随时进行； </p>
<p>数据项被事务T加锁并解锁之后，就不能再被事务T加锁。 </p>
<p>树形协议的优点是并发度好，因为可以较早地解锁。并且没有死锁，因为其加锁都是顺序进行的。 </p>
<p>缺点是对不需要访问的数据进行不必要的加锁</p>
<p>3.redu log</p>
<p>​       当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到 磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。 InnoDB 的 redo log 写满了。这时候系统会停止所有更新操作，把 checkpoint 往前推进，redo log 留出空间可以继续写。redo log是循环写    </p>
<p>​         InnoDB 每次写入的日志都有一个序号，当前写入的序号跟 checkpoint 对应的序号之间的差 值，我们假设为 N。InnoDB 会根据这个 N 算出一个范围在 0 到 100 之间的数字，这个计算公 式可以记为 F2(N)。F2(N) 算法比较复杂，你只要知道 N 越大，算出来的值越大就好了。<br>然后，根据上述算得的 F1(M) 和 F2(N) 两个值，取其中较大的值记为 R，之后引擎就可以按照 innodb_io_capacity 定义的能力乘以 R% 来控制刷脏页的速度的</p>
<p>​       <img src="https://github.com/wulimax/blogs/blob/master/docs/mysql/image/redulog.png" height="330" width="495"></p>
<p>一旦一个查询请求需要在执行过程中先 flush 掉一个脏页时，这个查询就可能要比平时慢了。而 MySQL 中的一个机制，可能让你的查询会更慢：在准备刷一个脏页的时候，如果这个数据页旁 边的数据页刚好是脏页，就会把这个“邻居”也带着一起刷掉；而且这个把“邻居”拖下水的逻 辑还可以继续蔓延，也就是对于每个邻居数据页，如果跟它相邻的数据页也还是脏页的话，也会 被放到一起刷。<br>在 InnoDB 中，innodb_flush_neighbors 参数就是用来控制这个行为的，值为 1 的时候会有上 述的“连坐”机制，值为 0 时表示不找邻居，自己刷自己的。<br>找“邻居”这个优化在机械硬盘时代是很有意义的，可以减少很多随机 IO。机械硬盘的随机 IOPS 一般只有几百，相同的逻辑操作减少随机 IO 就意味着系统性能的大幅度提升。<br>而如果使用的是 SSD 这类 IOPS 比较高的设备的话，我就建议你把 innodb_flush_neighbors 的值设置成 0。因为这时候 IOPS 往往不是瓶颈，而“只刷自己”，就能更快地执行完必要的刷 脏页操作，减少 SQL 语句响应时间。<br>在 MySQL 8.0 中，innodb_flush_neighbors 参数的默认值已经是 0 了</p>
<p>查询磁盘写能力设置 </p>
<p>show global variables like ‘%capacity%’;</p>
<p>innodb_io_capacity    200<br>innodb_io_capacity_max    2000</p>
<p>设置磁盘写能力 set global innodb_io_capacity=2000;</p>
<table>
<thead>
<tr>
<th>innodb_io_capacity</th>
<th>磁盘配置</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>单盘SAS/SATA</td>
</tr>
<tr>
<td>2000</td>
<td>SAS*12  RAID  10</td>
</tr>
<tr>
<td>5000</td>
<td>SSD</td>
</tr>
<tr>
<td>50000</td>
<td>FUSION-IO</td>
</tr>
</tbody></table>
<ol start="4">
<li><p>count()</p>
<p>  有朋友问我count()是怎么回事;</p>
<p>对于 count(主键 id) 来说，</p>
<p>​                 InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。<br>对于 count(1) 来说，</p>
<p>​                 InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一 个数字“1”进去，判断是不可能为空的，按行累加。<br>单看这两个用法的差别的话，你能对比出来，count(1) 执行得要比 count(主键 id) 快。因为从 引擎返回 id 会涉及到解析数据行，以及拷贝字段值的操作。<br>对于 count(字段) 来说：</p>
<ol>
<li>如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能 为 null，按行累加；</li>
<li>如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出 来再判断一下，不是 null 才累加。<br>也就是前面的第一条原则，server 层要什么字段，InnoDB 就返回什么字段。<br>但是 count(<em>) 是例外，并不会把全部字段取出来，而是专门做了优化，不取值。count(</em>) 肯定 不是 null，按行累加</li>
</ol>
</li>
</ol>
<p>​      结论: 按照效率排序的话，count(字段)&lt;count(主键 id)&lt;count(1)≈count( * )，所以我 建议你，尽量使用 count( * );</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wulimax.github.io/2019/09/16/docs/mysql/mysql_innodb/" data-id="ck0m2ip3j000uq4u1ed9w133e" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/09/16/docs/mysql/mysql_log/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2019/09/16/docs/mysql/mysql/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/09/16/url/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/09/16/README/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/09/16/docs/wx/README/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/09/16/docs/wx/intercepto/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/09/16/docs/TopN/README/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 wulimax<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>