<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>blogs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="HTTP -&amp;gt; QUIC协议之ORTT加密传输 在了解这个协议前我们先了解一下http近些年来的发展情况 一 http/1  http1.x  ​       缺陷:线程阻塞,同一时间 同一域名的请求数量限制超过限制数目会被阻塞 链接无法复用  header头携带内容过大增加传输成本 传输都是明文数据无法保证安全性  http1.0  ​          缺陷:游览器于服务器只保持短暂的链">
<meta name="keywords" content="php,java,javascript,node,go,lua,nginx,sphinx,elasticesarch,算法">
<meta property="og:type" content="article">
<meta property="og:title" content="blogs">
<meta property="og:url" content="https://wulimax.github.io/2019/09/16/docs/HTTP/newhttp/index.html">
<meta property="og:site_name" content="blogs">
<meta property="og:description" content="HTTP -&amp;gt; QUIC协议之ORTT加密传输 在了解这个协议前我们先了解一下http近些年来的发展情况 一 http/1  http1.x  ​       缺陷:线程阻塞,同一时间 同一域名的请求数量限制超过限制数目会被阻塞 链接无法复用  header头携带内容过大增加传输成本 传输都是明文数据无法保证安全性  http1.0  ​          缺陷:游览器于服务器只保持短暂的链">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-04-24T05:54:00.049Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="blogs">
<meta name="twitter:description" content="HTTP -&amp;gt; QUIC协议之ORTT加密传输 在了解这个协议前我们先了解一下http近些年来的发展情况 一 http/1  http1.x  ​       缺陷:线程阻塞,同一时间 同一域名的请求数量限制超过限制数目会被阻塞 链接无法复用  header头携带内容过大增加传输成本 传输都是明文数据无法保证安全性  http1.0  ​          缺陷:游览器于服务器只保持短暂的链">
  
    <link rel="alternate" href="/atom.xml" title="blogs" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">blogs</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://wulimax.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-docs/HTTP/newhttp" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/16/docs/HTTP/newhttp/" class="article-date">
  <time datetime="2019-09-16T07:05:47.582Z" itemprop="datePublished">2019-09-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>HTTP -&gt; QUIC协议之ORTT加密传输</p>
<p>在了解这个协议前我们先了解一下http近些年来的发展情况</p>
<p>一 http/1</p>
<ol>
<li><p>http1.x </p>
<p>​       缺陷:线程阻塞,同一时间 同一域名的请求数量限制超过限制数目会被阻塞 链接无法复用  header头携带内容过大增加传输成本 传输都是明文数据无法保证安全性</p>
</li>
<li><p>http1.0 </p>
<p>​          缺陷:游览器于服务器只保持短暂的链接 游览器每次都需要建立TCP链接 新建成本很高 规定新建请求必须<code>request-response</code>才能新建链接 ,可能发送阻塞</p>
</li>
<li><p>http1.1 </p>
<p>​      引入持久链接 即TCP默认不关闭,可以被多个请求复用,不用声明 Connoction : keep-alive 大多数游览器支持同时建立6个链接 –链接是顺序执行的也就意味着会发生阻塞</p>
<p>​       管道机制:同一个TCP客户端可以发起多个请求</p>
<p>​       分块传输: 即服务器产生一块就发送一块</p>
</li>
<li><p>http2.0 </p>
<p>​     http2.0基于 SPDY3 专注性能 对header进行压缩  采用二进制传输数据 比起http1.x文本传输更高效</p>
<p>​       SPDY增加了一个帧层用于多路复用，多个并发流通过一个TCP连接（或者其他可靠传输流）。这个帧层为类似HTTP的请求响应流进行了优化，现在运行在HTTP之上的应用也能运行在SPDY之上，对web应用开发者来说几乎不需要做什么改变。</p>
<p>SPDY会话在HTTP的基础之上提供了四项改进：</p>
<p>​    多路复用请求：在单个SPDY连接能并发的发起请求，并不限制请求数；<br>​    请求优先级：客户端能请求某个资源被优先传输。这避免了高优先级请求被非关键资源堵塞网络通道的问题；<br>​    头部压缩：客户端现在发送了大量冗余的HTTP头部信息。因为一个页面可能有50到100个子请求，这些数据是巨大的；<br>​    服务端推送流：服务端能向客户端推送数据不需要客户端发起一个请求。</p>
<p>SPDY视图保持已有的HTTP语义。所有的特性比如cookies，Etags，Vary headers，Content-Encoding协商，SPDY仅仅替换了网络数据传输方法。</p>
<p>​         SPDY是在会话层做出的改变 所有不会影响应用层http </p>
</li>
<li><p>http3.0 </p>
<p>​      http3.0 原生支持多路复用,http2是基于TCP的多路复用</p>
<p>​     相对安全 所有header body 都加密</p>
<p>​     向前纠错 一两个包出现异常也可以通过其他包解开,减少网络开销</p>
</li>
</ol>
<p>​               Google搞了一个基于UDP协议的QUIC协议,并应用在http3上 QUIC使用ORTT建立连接</p>
<p> 所谓的ORTT就是,通信双方通信连接时,第一个数据包便可以携带有效的业务数据数据</p>
<p>​            对于http而言需要三次握手 客户端发送SYN-&gt;服务员器, 服务器确定发送SYN确认包/ACK验证包-&gt;客户端,客户端发送ACK确认包-&gt;服务端</p>
<p>​           对于https而言除了三次握手还需要额外的TLS握手</p>
<p>​         ORTT 使用DH算法进行做秘钥协商</p>
<p>​          Step 0：配置服务器密钥对</p>
<p>​                     在生成一个素数和一个整数(是的一个原根，不懂可略过)，同时随机生成一个数，计算：</p>
<p>​                     将三元组打成一个config包。</p>
<p>​           Step 1：首次发起连接</p>
<p>​                      简单地发送Client Hello到。</p>
<p>​          Step 2：首次回应</p>
<p>​                             用config封装成一个数据包回复给，显然内含有元组。</p>
<p>​       Step 3：发送加密数据</p>
<p>​                     收到后随机生成一个数做如下计算：<br>​                   计算公钥：<br>​                    计算对称密钥：<br>​                    准备业务数据payload1，设加密函数为，将下列元组发送给： </p>
<p>​                       注意，该阶段开始，payload便是加密的了。</p>
<p>​      Step 4：发送加密数据</p>
<p>​                  收到后，做以下计算：<br>​                计算对称密钥：<br>​                 可以证明，和端的是相等的： </p>
<p>​                  因此可解密密文获取明文payload。</p>
<p>​                 也许你会觉得就可以做此后通信的对称密钥了吧，然而并不是。为了所谓的前向安全性，此时会继续生成第二个对称密钥<br>​                 在发送自己的payload2之前，随机生成一个数，做如下计算：<br>​                 计算新的通信公钥：<br>​                 计算新的通信对称密钥：<br>​                  有了新的通信对称密钥，就可以将下面的元组发送给了： </p>
<p>​                  这个元组中除了包含的加密数据之外，还包括新生成的一个公钥。</p>
<p>Step 5：收到的</p>
<p>​                收到发来的后，解出其中的，做如下运算：<br>​               计算新的通信密钥：(可以证明)<br>​               用可以正确解密出payload2。<br>​                   此后的通讯，和便可以用做通信对称密钥了。</p>
<p>值得注意的是，这个是在1个RTT内新生成的，虽然耗费了1个RTT协商出了这个，但是在这个RTT中业务数据却依然可以加密通信的，只不过使用的是，即使用记忆中的端配置协商出的一个“不安全”的密钥，该密钥仅仅加密一趟数据。</p>
<p>​      Step 6：和断开连接<br>​                和之间通信一会儿后，断开连接。 </p>
<p>​      Step 7：直接发送加密数据<br>​                   过了一会儿或者一段时间后，又想和通信，注意，此时已经有了的config元组，也许是缓存在内存了，也许是写入磁盘了，无论怎样，只要拥有，它就可以直接从Step 3开始了，也就是说直接通过以及自己生成的随机数私钥计算出一个对称密钥，然后直接发送payload了。<br>嗯，这就是所谓的0RTT。</p>
<p>Step 8：发送加密数据 </p>
<p>​          这里在收到的加密数据后，重复Step 4重新计算出一个新的“安全对称密钥”即可将之作为直至断开为止的对称密钥。</p>
<p>​       </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wulimax.github.io/2019/09/16/docs/HTTP/newhttp/" data-id="ck0m2ip2q0005q4u1fs3dfjay" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/09/16/docs/HTTP/README/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2019/09/16/docs/HTTP/http/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/09/16/url/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/09/16/README/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/09/16/docs/wx/README/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/09/16/docs/wx/intercepto/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/09/16/docs/TopN/README/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 wulimax<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>